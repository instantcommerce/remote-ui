import { render } from '../render.esnext';
import { createElement } from '../create-element.esnext';
import { cloneElement as cloneElement$1 } from '../clone-element.esnext';
import { REACT_ELEMENT_TYPE } from './render.esnext';

/**
 * Legacy version of createElement.
 */

function createFactory(type) {
  return createElement.bind(null, type);
}
/**
 * Check if the passed element is a valid (p)react node.
 * @param {*} element The element to check
 * @returns {boolean}
 */

function isValidElement(element) {
  return Boolean(element) && element.$$typeof === REACT_ELEMENT_TYPE;
}
/**
 * Wrap `cloneElement` to abort if the passed element is not a valid element and apply
 * all vnode normalizations.
 */


const cloneElement = (element, ...args) => {
  if (!isValidElement(element)) return element;
  return cloneElement$1(element, ...args);
};
/**
 * Remove a component tree from the DOM, including state and event handlers.
 * @param {import('./internal').PreactElement} container
 * @returns {boolean}
 */

function unmountComponentAtNode(container) {
  if (container._vnode) {
    render(null, container);
    return true;
  }

  return false;
}
/**
 * Deprecated way to control batched rendering inside the reconciler, but we
 * already schedule in batches inside our rendering code
 */

function unstable_batchedUpdates(callback, arg) {
  callback(arg);
}

export { cloneElement, createFactory, unmountComponentAtNode, unstable_batchedUpdates };
